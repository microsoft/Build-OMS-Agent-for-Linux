##Git Tagging/Branching Proposal

During regular development, developers will routinely create
[temporary branches](CONTRIBUTING.md)
for code reviews. These branches are not the focus of this document, as they
are generally short lived (as short as a few minutes, or as long as it takes
for a developer to complete his work).

When working on branch “develop” (equivalent of the improvement branch on Team
Foundation Server, our prior source code management system):

1. We will “normally” have one development stream: Branch “develop”. This is
the equivalent of the “improvement” branch in TFS, and represents our
“latest/greatest” code. Most developers work on this branch, or a sub-branch
of this branch, the majority of the time.

2. We will have a “master” branch; we will merge to this when we want to test
and stabilize for a release (if needed). Note that the “master” branch will
generally be the last “stable” release of the “develop” branch; no other
branches should be merged there. Once stabilized, we'll tag it for release.

In addition, we’ll have two categories of other branches in our repositories:

1. [Release branches](#Release Branches), and
2. Long-lived development branches. These would be for a long-lived development
effort (something that several people may work on, or something that may not be
checked in for some period of time). Eventually, as this work gets merged to the
“develop” branch and/or to a “release” branch, the long-lived development branch
will be deleted.

To manage a long-lived development branch, developers should create temporary
branches off of it. This allows code reviews in manageable chunks while still
allowing the long-lived development branch to be re-based if needed for ease
in future merging.

###Release Branches

In addition to the above, we can have any number of “release” branches. Examples
of such release branches might be “2016_URNext”. This would be intended as
a Update Rollup development branch for the 2016 release of Operations Manager,
for example.

Note that, in ‘git’, there is a difference for a branch and a tag. A branch is
something long-lived, intended for further checkins, while a tag is a one-time
snapshot of versions of files.

To further illustrate the difference: A tag represents a version of a particular
branch at a moment in time. A branch represents a separate thread of development
that may run concurrently with other development efforts on the same code base.
Changes to a branch may eventually be merged back into another branch to unify
them.

Usually you'll tag a particular version so that you can recreate it (i.e.
"v1.1.0-2"). A branch is more of a strategy to provide on-going updates on a
particular version of the code while continuing to do development on it.

Given that 2016_TP5 (Technical Preview 5) will be a “snapshot” of branch “master”,
it’s highly likely that “2016_TP5” will be a tag off of the master branch.
Note that if the "develop" branch is highly stable at the time of a release,
we may choose to simply skip merging to master and tagging the "develop"
branch.

Meanwhile, as we’re working on “2016_URNext” (a branch), when we decide to
actually ship a UR out of it, we can tag that to be “2016_UR1” (for the first
UR), leaving the “2016_URNext” branch for further work. Each time we ship code
for a supported release, we create a tag for that release (regardless if the
release is off of 2016_URNext or off of mainline or some other branch).

Tags can be created either on the master build project (bld-scxcore or
bld-omsagent), or on the individual repositories involved. If we do tag individual
repositories, it’s important to tag ALL repositories involved for a project (which
will clutter common projects with multiple tags from multiple consuming
projects). On the other hand, if we tag the master project, we get all subproject
dependencies saved automatically, and you have a meaningful tag for the specific
project being released. For this reason, tagging the master project is preferred.

Finally: Shell bundles, when generated by a project, should support the
“--source-references” qualifier. This qualifier will dump all relevant git commit
hashes (via qualifier “--source-references”) that went into producing that shell
bundle. This makes it very easy to see exactly what source code the shell bundle
represents.
